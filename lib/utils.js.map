{
  "version": 3,
  "sources": ["../src/utils.js"],
  "sourcesContent": ["\r\nimport assert from 'assert'\r\nimport { digest } from 'json-hash'\r\nimport * as is from './is'\r\n\r\n// S.R. Petrick, \"A Direct Determination of the Irredundant Forms of a Boolean Function from the Set of Prime Implicants\"\r\n// Technical Report AFCRC-TR-56-110, Air Force Cambridge Research Center, Cambridge, Mass., Apr. 1956.\r\nexport function patrics (minterms) {\r\n\r\n  // Get prime implicants.\r\n  let F = {}\r\n  for (let minterm of minterms) {\r\n    if (minterm[2] !== 'v') {\r\n      if (!F[minterm[0]]) {\r\n        F[minterm[0]] = minterm[3]\r\n      }\r\n    }\r\n  }\r\n\r\n  let P = []\r\n  let PO = {}\r\n  let alpha = 'abcdefghijklmnopqrstuvwxy'\r\n  let ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXY'\r\n  for (let k in F) {\r\n    let v = F[k]\r\n    let pk = k.split('').map(function (e, i) {\r\n      return { '0': ALPHA[i], '1': alpha[i], '-': null }[e] }\r\n    ).filter((e) => e).join('')\r\n    P.push([ pk, v ])\r\n    for (let pi of v) {\r\n      PO[pi] = true\r\n    }\r\n  }\r\n  let PI = Object.keys(PO).map((e) => parseInt(e)).sort()\r\n\r\n  // console.log('P:')\r\n  // P.forEach(function (p, i) {\r\n  //   console.log(`P${i}`, p[0], p[1].join(', '))\r\n  // })\r\n  //\r\n  // console.log('PI:')\r\n  // console.log(PI)\r\n  //\r\n  let PR = PI.map(function (pi) {\r\n    let r = []\r\n    P.forEach(function (e, i) {\r\n      if (e[1].indexOf(pi) !== -1) {\r\n        r.push(i)\r\n      }\r\n    })\r\n    return r.map((e) => `P${e}`)\r\n  })\r\n\r\n  // console.log('PR:', PR.map((e) => `(${e.join(' + ')})`).join(' '))\r\n\r\n  let PM = PR.map((e) => e.map((f) => [f]))\r\n  while (PM.length > 1) {\r\n    let p = PM.pop()\r\n    p.forEach((e) => {\r\n      e.forEach((e2) => {\r\n        PM.forEach((f) => {\r\n          f.forEach((g) => {\r\n            if (g.indexOf(e2) === -1) {\r\n              g.push(e2)\r\n            }\r\n          })\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  // return PM[0].map((e) => e.join('')).join('+')\r\n  // console.log('PM0:', PM[0].map((e) => e.join('*')).join(' + '))\r\n  return PM[0].map((e) => {\r\n    return e.map((f) => {\r\n      return P[parseInt(f.substr(1))][0]\r\n    }).join('')\r\n  }).join('+')\r\n}\r\n\r\nexport function patrics2 (minterms) {\r\n  let P = patrics(minterms)\r\n  let alpha = 'abcdefghijklmnopqrstuvwxy'\r\n  let ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXY'\r\n\r\n  let or = P.split('+').map(function (p) {\r\n\r\n    let and = p.split('').map((e) => alpha.indexOf(e)).filter((e) => e !== -1)\r\n    let nor = p.split('').map((e) => ALPHA.indexOf(e)).filter((e) => e !== -1)\r\n\r\n    let r = {}\r\n    if (and.length > 0) {\r\n      r.$and = and\r\n    }\r\n    if (nor.length > 0) {\r\n      r.$nor = nor\r\n    }\r\n    if (Object.keys(r).length > 0) {\r\n      return r\r\n    } else {\r\n      return null\r\n    }\r\n  })\r\n\r\n  if (or.length > 0) {\r\n    if (or.length === 1) {\r\n      return or[0]\r\n    } else {\r\n      return { $or: or }\r\n    }\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n// Minterm expansion.\r\nexport function mintermexp (minterms) {\r\n\r\n  function diff (a, b) {\r\n    let r = []\r\n    let n = 0\r\n    let f = false\r\n    for (let i = 0; i < a.length; i++) {\r\n      if ((a[i] === '0' && b[i] === '1') || (a[i] === '1' && b[i] === '0')) {\r\n        r.push('-')\r\n        if (++n > 1) {\r\n          f = true\r\n          break\r\n        }\r\n      } else {\r\n        if (a[i] === b[i]) {\r\n          r.push(a[i])\r\n        } else {\r\n          f = true\r\n          break\r\n        }\r\n      }\r\n    }\r\n    if (f) {\r\n      return false\r\n    } else {\r\n      return r.join('')\r\n    }\r\n  }\r\n\r\n  function combine1 (i) {\r\n    let r = []\r\n    for (; i < minterms.length; i++) {\r\n      let o = minterms[i][1]\r\n      for (let j = i + 1; j < minterms.length; j++) {\r\n        let od = minterms[j][1] - o\r\n        if (od === 0) {\r\n          continue\r\n        }\r\n        if (od === 1) {\r\n          let d = diff(minterms[i][0], minterms[j][0])\r\n          if (d) {\r\n            let _1s = d.split('').filter((e) => e === '1').length\r\n            minterms[i][2] = 'v'\r\n            minterms[j][2] = 'v'\r\n            let k = []\r\n            for (let z of [ minterms[i][3], minterms[j][3] ]) {\r\n              for (let l of z) {\r\n                if (k.indexOf(l) === -1) {\r\n                  k.push(l)\r\n                }\r\n              }\r\n            }\r\n            r.push([ d, _1s, ' ', k ])\r\n          }\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // r.sort((a, b) => a[1] - b[1])\r\n\r\n    for (let e of r) {\r\n      minterms.push(e)\r\n    }\r\n\r\n    return i\r\n  }\r\n\r\n  {\r\n    let i = 0\r\n    while (true) {\r\n      let j = combine1(i)\r\n      if (i == j) {\r\n        break\r\n      } else {\r\n        i = j\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Generate initial minterms.\r\nexport function minterms (q, n) {\r\n  let r = []\r\n  for (let i = 0; i < 2 ** n; i++) {\r\n\r\n    // String binary representation.\r\n    let s = new Array(n).fill('0').map((e, j) => ((1 << j) & i) ? '1' : '0' ).join('')\r\n\r\n    // Number of 1s.\r\n    let _1s = s.split('').filter((e) => e === '1').length\r\n\r\n    if (itest(q, i)) {\r\n      r.push([ s, _1s, ' ', [ i ] ])\r\n    }\r\n  }\r\n\r\n  // Sort by count of 1s.\r\n  r.sort((a, b) => a[1] - b[1])\r\n\r\n  return r\r\n}\r\n\r\nexport function itest2 (qa, qb, n) {\r\n  let r = true\r\n  for (let i = 0; i < 2 ** n; i++) {\r\n    let ra = itest(qa, i)\r\n    let rb = itest(qb, i)\r\n    if (ra !== rb) {\r\n      let s = new Array(n).fill('0').map((e, j) => ((1 << j) & i) ? '1' : '0' ).join('')\r\n      console.error(`${ra} !== ${rb} for ${s}`)\r\n      r = false\r\n      break\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\n// Perform query test using binary as input.\r\n//\r\n// @param [Object] q Index map query, ie. `{ $and: [ 0, { $or: [ 1, 2 ] } ] }`\r\n// @param [Number] i Binary input, ie. `0b101` means 0 - true, 1 - false, 2 - true.\r\n// @return [Boolean] True if criteria is satisfied, false otherwise.\r\nexport function itest (q, i) {\r\n  let r = false\r\n  if (is.number(q)) {\r\n    r = (1 << q) & i ? true : false\r\n  } else {\r\n    r = [ '$and', '$or', '$nor', '$not' ].every(\r\n      function (k) {\r\n        let r = true\r\n        if (is.none(q[k])) {\r\n          r = true\r\n        } else {\r\n          switch (k) {\r\n            case '$and':\r\n              r = q[k].every((e) => itest(e, i))\r\n              break\r\n            case '$or':\r\n              r = q[k].some((e) => itest(e, i))\r\n              break\r\n            case '$nor':\r\n              r = q[k].every((e) => !itest(e, i))\r\n              break\r\n            case '$not':\r\n              r = !itest(q[k], i)\r\n              break\r\n          }\r\n        }\r\n        return r\r\n      }\r\n    )\r\n  }\r\n  return r\r\n}\r\n\r\n// Map query to fragments.\r\nexport function map (q, f) {\r\n  let r = null\r\n  if (is.plain(q)) {\r\n    r = {}\r\n    let d = {}\r\n\r\n    // Split fragment and query parts.\r\n    for (let [ k, v ] of kvs(q)) {\r\n      if ([ '$and', '$or', '$nor' ].indexOf(k) !== -1) {\r\n        r[k] = map(v, f)\r\n      } else {\r\n        d[k] = v\r\n      }\r\n    }\r\n\r\n    if (!is.leaf(d)) {\r\n      let fd = f(d)\r\n      if (is.leaf(r)) {\r\n        r = fd\r\n      } else {\r\n        r = { $and: [ fd, r ] }\r\n      }\r\n    }\r\n  } else {\r\n    if (is.array(q)) {\r\n      r = q.map((e) => map(e, f))\r\n    } else {\r\n      r = f(q)\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nexport function unmap (q, fs) {\r\n  let r = null\r\n  if (is.plain(q)) {\r\n    r = {}\r\n    for (let [ k, v ] of kvs(q)) {\r\n      r[k] = unmap(v, fs)\r\n    }\r\n  } else {\r\n    if (is.array(q)) {\r\n      r = q.map((e) => unmap(e, fs))\r\n    } else {\r\n      r = fs[q][1]\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nexport function minimize (qr) {\r\n  let fs = []\r\n  let q = map(qr, (e) => {\r\n    let d = digest(e)\r\n    let i = fs.findIndex((f) => f[0] == d)\r\n    if (i === -1) {\r\n      i = fs.length\r\n      fs.push([ d, e ])\r\n    }\r\n    return i\r\n  })\r\n  let minterms_ = minterms(q, fs.length)\r\n  mintermexp(minterms_)\r\n  let p = patrics2(minterms_)\r\n  assert.ok((itest2(q, p, fs.length)))\r\n  let r = unmap(p, fs)\r\n  let rks = Object.keys(r)\r\n  if (rks.length === 1 && rks[0] === '$and' && r[rks[0]].length === 1) {\r\n    r = r[rks[0]][0]\r\n  }\r\n  return r\r\n}\r\n\r\nexport function biconditional (a, b) {\r\n  return (!!a ^ !!b) ? false : true\r\n}\r\n\r\n// Decode query key from ' $foo' -> '$foo'. Encoding allows to refer to document\r\n// attributes which would conflict with ops.\r\nexport function decoded (qk) {\r\n  let r = qk\r\n  let trim = false\r\n\r\nloop:\r\n  for (let i = 0; i < qk.length; i++) {\r\n    switch (qk[i]) {\r\n      case ' ':\r\n        trim = true\r\n        continue loop\r\n\r\n      case '$':\r\n        if (trim) {\r\n          r = qk.substr(1)\r\n        }\r\n        break loop\r\n\r\n      default:\r\n        break loop\r\n    }\r\n  }\r\n\r\n  return r\r\n}\r\n\r\n// Arrize path by splitting 'foo.bar' -> [ 'foo', 'bar' ], unless string starts\r\n// with ' ' then ' foo.bar' -> [ 'foo.bar' ].\r\nexport function split (a) {\r\n  let r = undefined\r\n  if (a[0] === ' ') {\r\n    r = [ a.substring(1) ]\r\n  } else {\r\n    r = a.split('.')\r\n  }\r\n  return r\r\n}\r\n\r\n// Resolve key path on an object.\r\nexport function resolve (a, path) {\r\n  let stack = split(path)\r\n  let last = []\r\n\r\n  if (stack.length > 0) {\r\n    last.unshift(stack.pop())\r\n  }\r\n\r\n  let k = undefined\r\n  let e = a\r\n  if (!is.none(e)) {\r\n    while (!is.none(k = stack.shift())) {\r\n      if (!is.none(e[k])) {\r\n        e = e[k]\r\n      } else {\r\n        stack.unshift(k)\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // Pull all unresolved components into last.\r\n  while (!is.none((k = stack.pop()))) {\r\n    last.unshift(k)\r\n  }\r\n\r\n  return [ e, last ]\r\n}\r\n\r\nexport function arrize (a) {\r\n  return Array.isArray(a) ? a : [ a ]\r\n}\r\n\r\nexport function* kvs (a) {\r\n  if (is.object(a)) {\r\n    for (let k of Object.keys(a)) {\r\n      if (a.hasOwnProperty(k)) {\r\n        yield [k, a[k]]\r\n      }\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["minterms", "r", "assert"]
}
